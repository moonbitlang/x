// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/x/rational"

import(
  "moonbitlang/core/bigint"
  "moonbitlang/core/quickcheck"
  "moonbitlang/core/quickcheck/splitmix"
)

// Values
fn from_double(Double) -> Rational[Int64] raise RationalError

fn[T : Integral] new(T, T) -> Rational[T]?

// Errors
pub(all) suberror RationalError String
fn RationalError::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn RationalError::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RationalError::output(Self, &Logger) -> Unit // from trait `Show`
fn RationalError::to_json(Self) -> Json // from trait `ToJson`
fn RationalError::to_string(Self) -> String // from trait `Show`
impl Eq for RationalError
impl Show for RationalError
impl ToJson for RationalError

// Types and methods
type Rational[T]
#as_free_fn
fn[T : Integral] Rational::abs(Self[T]) -> Self[T]
fn[T : Integral] Rational::add(Self[T], Self[T]) -> Self[T] // from trait `Add`
fn[T : Integral] Rational::arbitrary(Int, @splitmix.RandomState) -> Self[T] // from trait `@quickcheck.Arbitrary`
#as_free_fn
fn[T : Integral] Rational::ceil(Self[T]) -> T
fn[T : Integral] Rational::compare(Self[T], Self[T]) -> Int // from trait `Compare`
fn[T : Integral] Rational::div(Self[T], Self[T]) -> Self[T] // from trait `Div`
fn[T : Eq] Rational::equal(Self[T], Self[T]) -> Bool // from trait `Eq`
#as_free_fn
fn[T : Integral] Rational::floor(Self[T]) -> T
#as_free_fn
fn[T : Integral] Rational::fract(Self[T]) -> Self[T]
#as_free_fn
fn[T : Integral] Rational::is_integer(Self[T]) -> Bool
fn[T : Integral] Rational::mul(Self[T], Self[T]) -> Self[T] // from trait `Mul`
fn[T : Integral] Rational::neg(Self[T]) -> Self[T] // from trait `Neg`
#deprecated
fn[T : Integral] Rational::op_add(Self[T], Self[T]) -> Self[T] // from trait `Add`
#deprecated
fn[T : Integral] Rational::op_div(Self[T], Self[T]) -> Self[T] // from trait `Div`
#deprecated
fn[T : Eq] Rational::op_equal(Self[T], Self[T]) -> Bool // from trait `Eq`
#deprecated
fn[T : Integral] Rational::op_mul(Self[T], Self[T]) -> Self[T] // from trait `Mul`
#deprecated
fn[T : Integral] Rational::op_neg(Self[T]) -> Self[T] // from trait `Neg`
#deprecated
fn[T : Integral] Rational::op_sub(Self[T], Self[T]) -> Self[T] // from trait `Sub`
fn[T : Integral] Rational::output(Self[T], &Logger) -> Unit // from trait `Show`
#as_free_fn
fn[T : Integral] Rational::reciprocal(Self[T]) -> Self[T]
fn[T : Integral] Rational::sub(Self[T], Self[T]) -> Self[T] // from trait `Sub`
fn Rational::to_double(Self[Int64]) -> Double
fn[T : Integral] Rational::to_string(Self[T]) -> String // from trait `Show`
#as_free_fn
fn[T : Integral] Rational::trunc(Self[T]) -> T
impl[T : Integral] Add for Rational[T]
impl[T : Integral] Compare for Rational[T]
impl[T : Integral] Div for Rational[T]
impl[T : Eq] Eq for Rational[T]
impl[T : Integral] Mul for Rational[T]
impl[T : Integral] Neg for Rational[T]
impl[T : Integral] Show for Rational[T]
impl[T : Integral] Sub for Rational[T]
impl[T : Integral] @quickcheck.Arbitrary for Rational[T]

// Type aliases
pub typealias Rational[@bigint.BigInt] as BigRational

pub typealias Rational[Int] as Rational32

pub typealias Rational[Int64] as Rational64

// Traits
trait Integral : Add + Sub + Mul + Div + Neg + Mod + Show + Eq + Compare + @quickcheck.Arbitrary
impl Integral for Int
impl Integral for Int64
impl Integral for @bigint.BigInt

